package com.project.player.queue.consumer;

import java.util.concurrent.atomic.AtomicBoolean;
import java.util.concurrent.atomic.AtomicInteger;

import com.project.player.entity.MessagePlayer;
import com.project.player.queue.BasicConsumeQueue;
import com.project.player.queue.BufferTask;
import com.project.player.service.MessageService;

/**
 * The Consumer class is concrete bufferTask responsible for to consume messages
 * from queue generated by players.
 * 
 * After to consume message from queue, call the messageService class to process
 * message and to apply business rules.
 * 
 * 
 * 
 * @author rafaelteckgomes
 *
 */
public class Consumer implements BufferTask {

	private BasicConsumeQueue<MessagePlayer> consumerQueue;

	private final AtomicBoolean keepRunning = new AtomicBoolean(true);

	private final AtomicInteger counter = new AtomicInteger(0);

	private int sizeToProcess = 0;

	private MessageService messageService;

	private boolean initiator = false;

	public Consumer(BasicConsumeQueue<MessagePlayer> basicQueue, MessageService messageService, int sizeToProcess, boolean initiator) {
		this.consumerQueue = basicQueue;
		this.sizeToProcess = sizeToProcess;
		this.messageService = messageService;
		this.initiator = initiator;
	}

	public void run() {

		while (keepRunning.get()) {
			if (!consumerQueue.isEmpty()) {
				MessagePlayer msg = consumerQueue.getValue();
				if (null != msg) {
					System.out.println(Thread.currentThread().getName() + " Received message: " + msg.toString());
					messageService.processMessage(msg, counter, initiator);
				}
			}

			try {
				Thread.sleep(1000);
			} catch (InterruptedException e) {
				Thread.currentThread().interrupt();
				System.out.println("Thread was interrupted, Failed to complete operation");
			}
		}

	}

	public void terminate() {
		keepRunning.set(false);
	}

	public boolean hasFinished() {
		return counter.get() == sizeToProcess;
	}

}
